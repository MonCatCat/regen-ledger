// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/v1/state.proto

package core

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/api/cosmos/orm/v1alpha1"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CreditType defines the measurement unit/precision of a certain credit type
// (e.g. carbon, biodiversity...)
type CreditType struct {
	// abbreviation is a 1-3 character uppercase abbreviation of the CreditType
	// name, used in batch denominations within the CreditType. It must be unique.
	Abbreviation string `protobuf:"bytes,1,opt,name=abbreviation,proto3" json:"abbreviation,omitempty"`
	// the type of credit (e.g. carbon, biodiversity, etc)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// the measurement unit (e.g. kg, ton, etc)
	Unit string `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
	// the decimal precision
	Precision uint32 `protobuf:"varint,4,opt,name=precision,proto3" json:"precision,omitempty"`
}

func (m *CreditType) Reset()         { *m = CreditType{} }
func (m *CreditType) String() string { return proto.CompactTextString(m) }
func (*CreditType) ProtoMessage()    {}
func (*CreditType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{0}
}
func (m *CreditType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreditType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreditType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreditType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreditType.Merge(m, src)
}
func (m *CreditType) XXX_Size() int {
	return m.Size()
}
func (m *CreditType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreditType.DiscardUnknown(m)
}

var xxx_messageInfo_CreditType proto.InternalMessageInfo

func (m *CreditType) GetAbbreviation() string {
	if m != nil {
		return m.Abbreviation
	}
	return ""
}

func (m *CreditType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreditType) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *CreditType) GetPrecision() uint32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

// ClassInfo represents the high-level on-chain information for a credit class.
type ClassInfo struct {
	// id is the unique ID of credit class.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// abbrev is the unique string name for this credit class formed from its
	// credit type and an auto-generated integer.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// admin is the admin of the credit class.
	Admin []byte `protobuf:"bytes,3,opt,name=admin,proto3" json:"admin,omitempty"`
	// metadata is any arbitrary metadata to attached to the credit class.
	Metadata string `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// credit_type_abbreviation is the abbreviation of the credit type.
	CreditTypeAbbreviation string `protobuf:"bytes,5,opt,name=credit_type_abbreviation,json=creditTypeAbbreviation,proto3" json:"credit_type_abbreviation,omitempty"`
}

func (m *ClassInfo) Reset()         { *m = ClassInfo{} }
func (m *ClassInfo) String() string { return proto.CompactTextString(m) }
func (*ClassInfo) ProtoMessage()    {}
func (*ClassInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{1}
}
func (m *ClassInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassInfo.Merge(m, src)
}
func (m *ClassInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClassInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClassInfo proto.InternalMessageInfo

func (m *ClassInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ClassInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClassInfo) GetAdmin() []byte {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *ClassInfo) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *ClassInfo) GetCreditTypeAbbreviation() string {
	if m != nil {
		return m.CreditTypeAbbreviation
	}
	return ""
}

// ClassIssuers is a JOIN table for Class Info that stores the credit class
// issuers
type ClassIssuer struct {
	// class_id is the row ID of a credit class.
	ClassId uint64 `protobuf:"varint,1,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// issuer is the approved issuer of the credit class.
	Issuer []byte `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
}

func (m *ClassIssuer) Reset()         { *m = ClassIssuer{} }
func (m *ClassIssuer) String() string { return proto.CompactTextString(m) }
func (*ClassIssuer) ProtoMessage()    {}
func (*ClassIssuer) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{2}
}
func (m *ClassIssuer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassIssuer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassIssuer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassIssuer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassIssuer.Merge(m, src)
}
func (m *ClassIssuer) XXX_Size() int {
	return m.Size()
}
func (m *ClassIssuer) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassIssuer.DiscardUnknown(m)
}

var xxx_messageInfo_ClassIssuer proto.InternalMessageInfo

func (m *ClassIssuer) GetClassId() uint64 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *ClassIssuer) GetIssuer() []byte {
	if m != nil {
		return m.Issuer
	}
	return nil
}

// ProjectInfo represents the high-level on-chain information for a project.
type ProjectInfo struct {
	// id is the unique ID of the project.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the unique name of the project either formed from its credit
	// class name and an auto-generated number or a custom name provided
	// upon creation.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// admin is the admin of the project.
	Admin []byte `protobuf:"bytes,3,opt,name=admin,proto3" json:"admin,omitempty"`
	// class_id is the ID of credit class for this project.
	ClassId uint64 `protobuf:"varint,4,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// project_location is the location of the project.
	// Full documentation can be found in MsgCreateProject.project_location.
	ProjectLocation string `protobuf:"bytes,5,opt,name=project_location,json=projectLocation,proto3" json:"project_location,omitempty"`
	// metadata is any arbitrary metadata attached to the project.
	Metadata string `protobuf:"bytes,6,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *ProjectInfo) Reset()         { *m = ProjectInfo{} }
func (m *ProjectInfo) String() string { return proto.CompactTextString(m) }
func (*ProjectInfo) ProtoMessage()    {}
func (*ProjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{3}
}
func (m *ProjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectInfo.Merge(m, src)
}
func (m *ProjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectInfo proto.InternalMessageInfo

func (m *ProjectInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProjectInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProjectInfo) GetAdmin() []byte {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *ProjectInfo) GetClassId() uint64 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *ProjectInfo) GetProjectLocation() string {
	if m != nil {
		return m.ProjectLocation
	}
	return ""
}

func (m *ProjectInfo) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

// BatchInfo represents the high-level on-chain information for a credit batch.
type BatchInfo struct {
	// id is an auto-incrementing integer to succinctly identify the batch
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// issuer is the address that created the batch and which is
	// authorized to mint more credits if open=true.
	Issuer []byte `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// project_id is the unique ID of the project this batch belongs to.
	ProjectId uint64 `protobuf:"varint,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// batch_denom is the unique string identifier of the credit batch formed
	// from the project name, batch sequence number and dates.
	BatchDenom string `protobuf:"bytes,4,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// metadata is any arbitrary metadata attached to the credit batch.
	Metadata string `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// start_date is the beginning of the period during which this credit batch
	// was quantified and verified.
	StartDate *types.Timestamp `protobuf:"bytes,6,opt,name=start_date,json=startDate,proto3" json:"start_date,omitempty"`
	// end_date is the end of the period during which this credit batch was
	// quantified and verified.
	EndDate *types.Timestamp `protobuf:"bytes,7,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty"`
	// issuance_date is the timestamp when the credit batch was issued.
	IssuanceDate *types.Timestamp `protobuf:"bytes,8,opt,name=issuance_date,json=issuanceDate,proto3" json:"issuance_date,omitempty"`
	// open tells if it's possible to mint new credits in the future.
	// Once `open` is set to false, it can't be toggled any more.
	Open bool `protobuf:"varint,9,opt,name=open,proto3" json:"open,omitempty"`
}

func (m *BatchInfo) Reset()         { *m = BatchInfo{} }
func (m *BatchInfo) String() string { return proto.CompactTextString(m) }
func (*BatchInfo) ProtoMessage()    {}
func (*BatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{4}
}
func (m *BatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchInfo.Merge(m, src)
}
func (m *BatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *BatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BatchInfo proto.InternalMessageInfo

func (m *BatchInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BatchInfo) GetIssuer() []byte {
	if m != nil {
		return m.Issuer
	}
	return nil
}

func (m *BatchInfo) GetProjectId() uint64 {
	if m != nil {
		return m.ProjectId
	}
	return 0
}

func (m *BatchInfo) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *BatchInfo) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *BatchInfo) GetStartDate() *types.Timestamp {
	if m != nil {
		return m.StartDate
	}
	return nil
}

func (m *BatchInfo) GetEndDate() *types.Timestamp {
	if m != nil {
		return m.EndDate
	}
	return nil
}

func (m *BatchInfo) GetIssuanceDate() *types.Timestamp {
	if m != nil {
		return m.IssuanceDate
	}
	return nil
}

func (m *BatchInfo) GetOpen() bool {
	if m != nil {
		return m.Open
	}
	return false
}

// ClassSequence is a sequence number for creating credit class identifiers for
// each credit type.
type ClassSequence struct {
	// credit_type_abbreviation is the credit type abbreviation
	CreditTypeAbbreviation string `protobuf:"bytes,1,opt,name=credit_type_abbreviation,json=creditTypeAbbreviation,proto3" json:"credit_type_abbreviation,omitempty"`
	// next_class_id is the next class ID for this credit type
	NextClassId uint64 `protobuf:"varint,2,opt,name=next_class_id,json=nextClassId,proto3" json:"next_class_id,omitempty"`
}

func (m *ClassSequence) Reset()         { *m = ClassSequence{} }
func (m *ClassSequence) String() string { return proto.CompactTextString(m) }
func (*ClassSequence) ProtoMessage()    {}
func (*ClassSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{5}
}
func (m *ClassSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassSequence.Merge(m, src)
}
func (m *ClassSequence) XXX_Size() int {
	return m.Size()
}
func (m *ClassSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassSequence.DiscardUnknown(m)
}

var xxx_messageInfo_ClassSequence proto.InternalMessageInfo

func (m *ClassSequence) GetCreditTypeAbbreviation() string {
	if m != nil {
		return m.CreditTypeAbbreviation
	}
	return ""
}

func (m *ClassSequence) GetNextClassId() uint64 {
	if m != nil {
		return m.NextClassId
	}
	return 0
}

// ProjectSequence stores and increments the sequence number for projects
// within a given credit class.
type ProjectSequence struct {
	// class_id is the id of the credit class
	ClassId uint64 `protobuf:"varint,1,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// next_project_id is the sequence number for the project
	NextProjectId uint64 `protobuf:"varint,2,opt,name=next_project_id,json=nextProjectId,proto3" json:"next_project_id,omitempty"`
}

func (m *ProjectSequence) Reset()         { *m = ProjectSequence{} }
func (m *ProjectSequence) String() string { return proto.CompactTextString(m) }
func (*ProjectSequence) ProtoMessage()    {}
func (*ProjectSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{6}
}
func (m *ProjectSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectSequence.Merge(m, src)
}
func (m *ProjectSequence) XXX_Size() int {
	return m.Size()
}
func (m *ProjectSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectSequence.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectSequence proto.InternalMessageInfo

func (m *ProjectSequence) GetClassId() uint64 {
	if m != nil {
		return m.ClassId
	}
	return 0
}

func (m *ProjectSequence) GetNextProjectId() uint64 {
	if m != nil {
		return m.NextProjectId
	}
	return 0
}

// BatchSequence tracks the sequence number for batches within a project
type BatchSequence struct {
	// project_id is the id of the project for a batch
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// next_batch_id is a sequence number incrementing on each issued batch
	NextBatchId uint64 `protobuf:"varint,2,opt,name=next_batch_id,json=nextBatchId,proto3" json:"next_batch_id,omitempty"`
}

func (m *BatchSequence) Reset()         { *m = BatchSequence{} }
func (m *BatchSequence) String() string { return proto.CompactTextString(m) }
func (*BatchSequence) ProtoMessage()    {}
func (*BatchSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{7}
}
func (m *BatchSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSequence.Merge(m, src)
}
func (m *BatchSequence) XXX_Size() int {
	return m.Size()
}
func (m *BatchSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSequence.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSequence proto.InternalMessageInfo

func (m *BatchSequence) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *BatchSequence) GetNextBatchId() uint64 {
	if m != nil {
		return m.NextBatchId
	}
	return 0
}

// BatchBalance stores each users credit balance
type BatchBalance struct {
	// address is the address of the credit holder
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// batch_id is the id of the credit batch
	BatchId uint64 `protobuf:"varint,2,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// tradable is the tradable amount of credits
	Tradable string `protobuf:"bytes,3,opt,name=tradable,proto3" json:"tradable,omitempty"`
	// retired is the retired amount of credits
	Retired string `protobuf:"bytes,4,opt,name=retired,proto3" json:"retired,omitempty"`
	// escrowed is the amount of credits locked up in escrow for the marketplace.
	Escrowed string `protobuf:"bytes,5,opt,name=escrowed,proto3" json:"escrowed,omitempty"`
}

func (m *BatchBalance) Reset()         { *m = BatchBalance{} }
func (m *BatchBalance) String() string { return proto.CompactTextString(m) }
func (*BatchBalance) ProtoMessage()    {}
func (*BatchBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{8}
}
func (m *BatchBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchBalance.Merge(m, src)
}
func (m *BatchBalance) XXX_Size() int {
	return m.Size()
}
func (m *BatchBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchBalance.DiscardUnknown(m)
}

var xxx_messageInfo_BatchBalance proto.InternalMessageInfo

func (m *BatchBalance) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *BatchBalance) GetBatchId() uint64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *BatchBalance) GetTradable() string {
	if m != nil {
		return m.Tradable
	}
	return ""
}

func (m *BatchBalance) GetRetired() string {
	if m != nil {
		return m.Retired
	}
	return ""
}

func (m *BatchBalance) GetEscrowed() string {
	if m != nil {
		return m.Escrowed
	}
	return ""
}

// BatchSupply tracks the supply of a credit batch
type BatchSupply struct {
	// batch_id is the id of the batch
	BatchId uint64 `protobuf:"varint,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// tradable_amount is the total number of tradable credits in the credit
	// batch. Some of the issued credits may be cancelled and will be removed from
	// tradable_amount and tracked in amount_cancelled. tradable_amount +
	// retired_amount + amount_cancelled will always sum to the original credit
	// issuance amount.
	TradableAmount string `protobuf:"bytes,2,opt,name=tradable_amount,json=tradableAmount,proto3" json:"tradable_amount,omitempty"`
	// retired_amount is the total amount of credits that have been retired from
	// the credit batch.
	RetiredAmount string `protobuf:"bytes,3,opt,name=retired_amount,json=retiredAmount,proto3" json:"retired_amount,omitempty"`
	// cancelled_amount is the number of credits in the batch that have been
	// cancelled, effectively undoing the issuance. The sum of total_amount and
	// amount_cancelled will always equal the original credit issuance amount.
	CancelledAmount string `protobuf:"bytes,4,opt,name=cancelled_amount,json=cancelledAmount,proto3" json:"cancelled_amount,omitempty"`
}

func (m *BatchSupply) Reset()         { *m = BatchSupply{} }
func (m *BatchSupply) String() string { return proto.CompactTextString(m) }
func (*BatchSupply) ProtoMessage()    {}
func (*BatchSupply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{9}
}
func (m *BatchSupply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSupply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSupply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSupply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSupply.Merge(m, src)
}
func (m *BatchSupply) XXX_Size() int {
	return m.Size()
}
func (m *BatchSupply) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSupply.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSupply proto.InternalMessageInfo

func (m *BatchSupply) GetBatchId() uint64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *BatchSupply) GetTradableAmount() string {
	if m != nil {
		return m.TradableAmount
	}
	return ""
}

func (m *BatchSupply) GetRetiredAmount() string {
	if m != nil {
		return m.RetiredAmount
	}
	return ""
}

func (m *BatchSupply) GetCancelledAmount() string {
	if m != nil {
		return m.CancelledAmount
	}
	return ""
}

// BatchOrigTx will index batch mint operations using orig tx ID to handle
// potential double minting errors
type BatchOrigTx struct {
	// the id of an originating transaction or opeartion.
	TxId string `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	// type of the transaction originating the mint process. Eg: Polygon,
	// Ethereum, Verra...
	Typ string `protobuf:"bytes,2,opt,name=typ,proto3" json:"typ,omitempty"`
	// reference note for accounting, will be passed to an event
	Note string `protobuf:"bytes,3,opt,name=note,proto3" json:"note,omitempty"`
	// batch_denom is the unique ID of the credit batch.
	BatchDenom string `protobuf:"bytes,4,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
}

func (m *BatchOrigTx) Reset()         { *m = BatchOrigTx{} }
func (m *BatchOrigTx) String() string { return proto.CompactTextString(m) }
func (*BatchOrigTx) ProtoMessage()    {}
func (*BatchOrigTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cfdca0a4aaabb36, []int{10}
}
func (m *BatchOrigTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchOrigTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchOrigTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchOrigTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchOrigTx.Merge(m, src)
}
func (m *BatchOrigTx) XXX_Size() int {
	return m.Size()
}
func (m *BatchOrigTx) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchOrigTx.DiscardUnknown(m)
}

var xxx_messageInfo_BatchOrigTx proto.InternalMessageInfo

func (m *BatchOrigTx) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *BatchOrigTx) GetTyp() string {
	if m != nil {
		return m.Typ
	}
	return ""
}

func (m *BatchOrigTx) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *BatchOrigTx) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func init() {
	proto.RegisterType((*CreditType)(nil), "regen.ecocredit.v1.CreditType")
	proto.RegisterType((*ClassInfo)(nil), "regen.ecocredit.v1.ClassInfo")
	proto.RegisterType((*ClassIssuer)(nil), "regen.ecocredit.v1.ClassIssuer")
	proto.RegisterType((*ProjectInfo)(nil), "regen.ecocredit.v1.ProjectInfo")
	proto.RegisterType((*BatchInfo)(nil), "regen.ecocredit.v1.BatchInfo")
	proto.RegisterType((*ClassSequence)(nil), "regen.ecocredit.v1.ClassSequence")
	proto.RegisterType((*ProjectSequence)(nil), "regen.ecocredit.v1.ProjectSequence")
	proto.RegisterType((*BatchSequence)(nil), "regen.ecocredit.v1.BatchSequence")
	proto.RegisterType((*BatchBalance)(nil), "regen.ecocredit.v1.BatchBalance")
	proto.RegisterType((*BatchSupply)(nil), "regen.ecocredit.v1.BatchSupply")
	proto.RegisterType((*BatchOrigTx)(nil), "regen.ecocredit.v1.BatchOrigTx")
}

func init() { proto.RegisterFile("regen/ecocredit/v1/state.proto", fileDescriptor_6cfdca0a4aaabb36) }

var fileDescriptor_6cfdca0a4aaabb36 = []byte{
	// 974 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcb, 0x6e, 0x1c, 0x45,
	0x14, 0x75, 0xcd, 0x7b, 0xee, 0xbc, 0xda, 0x15, 0x63, 0x35, 0x43, 0x32, 0xb1, 0x5a, 0x3c, 0x1c,
	0x61, 0x66, 0x34, 0x41, 0x20, 0x98, 0x4d, 0x14, 0x27, 0x2c, 0x2c, 0x21, 0x25, 0x1a, 0xbc, 0x42,
	0x42, 0xa3, 0x9a, 0xae, 0xca, 0xb8, 0x4d, 0x77, 0x57, 0xd3, 0x5d, 0xe3, 0x8c, 0x25, 0xbe, 0x01,
	0x21, 0xb1, 0x45, 0x6c, 0xf9, 0x06, 0xfe, 0x00, 0x76, 0x91, 0xd8, 0xb0, 0x60, 0x81, 0xec, 0x3f,
	0xe0, 0x0b, 0x50, 0xdf, 0xea, 0x6a, 0x77, 0x47, 0x8e, 0xbd, 0x60, 0x57, 0xf7, 0xd6, 0x7d, 0x9c,
	0x73, 0x1f, 0xa5, 0x82, 0x51, 0x2c, 0x56, 0x22, 0x9c, 0x08, 0x57, 0xba, 0xb1, 0xe0, 0x9e, 0x9a,
	0x9c, 0x4d, 0x27, 0x89, 0x62, 0x4a, 0x8c, 0xa3, 0x58, 0x2a, 0x49, 0x29, 0xde, 0x8f, 0xf3, 0xfb,
	0xf1, 0xd9, 0x74, 0x78, 0xcf, 0x95, 0x49, 0x20, 0x93, 0x89, 0x8c, 0x83, 0xc9, 0xd9, 0x94, 0xf9,
	0xd1, 0x09, 0x9b, 0xa6, 0x82, 0x76, 0x19, 0xde, 0x5f, 0x49, 0xb9, 0xf2, 0xc5, 0x04, 0xa5, 0xe5,
	0xfa, 0xc5, 0x44, 0x79, 0x81, 0x48, 0x14, 0x0b, 0x22, 0x6d, 0xe0, 0xfc, 0x4c, 0x00, 0x9e, 0x60,
	0xb4, 0xe3, 0xf3, 0x48, 0x50, 0x07, 0xba, 0x6c, 0xb9, 0x8c, 0xc5, 0x99, 0xc7, 0x94, 0x27, 0x43,
	0x9b, 0xec, 0x91, 0xfd, 0xf6, 0xbc, 0xa4, 0xa3, 0x14, 0x6a, 0x21, 0x0b, 0x84, 0x5d, 0xc1, 0x3b,
	0x3c, 0xa7, 0xba, 0x75, 0xe8, 0x29, 0xbb, 0xaa, 0x75, 0xe9, 0x99, 0xde, 0x85, 0x76, 0x14, 0x0b,
	0xd7, 0x4b, 0xd2, 0x40, 0xb5, 0x3d, 0xb2, 0xdf, 0x9b, 0x5f, 0x29, 0x66, 0xef, 0xfe, 0xfb, 0xcb,
	0x9f, 0x3f, 0x54, 0x47, 0xd0, 0x2f, 0x67, 0xa4, 0xa0, 0xa3, 0x5b, 0xc4, 0x26, 0x36, 0x71, 0x2e,
	0x08, 0xb4, 0x9f, 0xf8, 0x2c, 0x49, 0x8e, 0xc2, 0x17, 0x92, 0xf6, 0xa1, 0xe2, 0x71, 0xc4, 0x54,
	0x9b, 0x57, 0x3c, 0x7e, 0x2d, 0x92, 0x1d, 0xa8, 0x33, 0x1e, 0x78, 0x21, 0x42, 0xe9, 0xce, 0xb5,
	0x40, 0x87, 0xd0, 0x0a, 0x84, 0x62, 0x9c, 0x29, 0x86, 0x50, 0xda, 0xf3, 0x5c, 0xa6, 0x9f, 0x81,
	0xad, 0xeb, 0xb9, 0x50, 0xe7, 0x91, 0x58, 0x94, 0xf8, 0xd7, 0xd1, 0x76, 0xd7, 0xcd, 0x2b, 0xf4,
	0xb8, 0x70, 0x3b, 0xfb, 0x02, 0x39, 0x3c, 0x82, 0x46, 0x8a, 0xcb, 0x22, 0x45, 0xec, 0xb4, 0x9d,
	0xe1, 0xb0, 0x2a, 0xf4, 0xee, 0x9b, 0x13, 0x58, 0x55, 0xbb, 0xe2, 0x7c, 0x03, 0x1d, 0xcd, 0x31,
	0x49, 0xd6, 0x22, 0xa6, 0x6f, 0x43, 0xcb, 0x4d, 0xc5, 0x45, 0xce, 0xb5, 0x89, 0xf2, 0x11, 0xa7,
	0xbb, 0xd0, 0xf0, 0xd0, 0x08, 0x29, 0x77, 0xe7, 0x99, 0x34, 0x7b, 0x07, 0x81, 0xbc, 0x05, 0xdb,
	0x30, 0x30, 0xae, 0x07, 0x99, 0x61, 0xd5, 0xf9, 0x9b, 0x40, 0xe7, 0x79, 0x2c, 0x4f, 0x85, 0xab,
	0xfe, 0x67, 0x15, 0x8b, 0xc8, 0x6a, 0x65, 0x64, 0x0f, 0xc0, 0x8a, 0x74, 0x8e, 0x85, 0x2f, 0xdd,
	0x62, 0xf1, 0x06, 0x99, 0xfe, 0xcb, 0x4c, 0x5d, 0xea, 0x45, 0xa3, 0xdc, 0x8b, 0xd9, 0x14, 0x89,
	0x7c, 0x78, 0x6d, 0x45, 0xef, 0x40, 0x2f, 0x27, 0x87, 0xca, 0x8a, 0x4d, 0xec, 0x9a, 0xf3, 0x6b,
	0x15, 0xda, 0x87, 0x4c, 0xb9, 0x27, 0xd7, 0x92, 0x7b, 0x43, 0xc5, 0xe8, 0x3d, 0x00, 0x83, 0xd7,
	0xe3, 0xc8, 0xb2, 0x96, 0x4e, 0xa7, 0xae, 0x12, 0xa7, 0xf7, 0xa1, 0xb3, 0x4c, 0x63, 0x2e, 0xb8,
	0x08, 0x65, 0x90, 0x8d, 0x0c, 0xa0, 0xea, 0x69, 0xaa, 0x29, 0x91, 0xa8, 0xbf, 0x36, 0x50, 0x9f,
	0x03, 0x24, 0x8a, 0xc5, 0x6a, 0xc1, 0x99, 0x12, 0x48, 0xb1, 0xf3, 0x70, 0x38, 0xd6, 0x9b, 0x38,
	0x36, 0x9b, 0x38, 0x3e, 0x36, 0x9b, 0x38, 0x6f, 0xa3, 0xf5, 0x53, 0xa6, 0x04, 0xfd, 0x04, 0x5a,
	0x22, 0xe4, 0xda, 0xb1, 0x79, 0xab, 0x63, 0x53, 0x84, 0x1c, 0xdd, 0x1e, 0x41, 0x2f, 0xe5, 0xc5,
	0x42, 0x57, 0x68, 0xdf, 0xd6, 0xad, 0xbe, 0x5d, 0xe3, 0x80, 0x01, 0x28, 0xd4, 0x64, 0x24, 0x42,
	0xbb, 0xbd, 0x47, 0xf6, 0x5b, 0x73, 0x3c, 0xcf, 0x9e, 0x61, 0x2f, 0x8e, 0xf2, 0x5e, 0x6c, 0x97,
	0x6a, 0x82, 0x2d, 0xe9, 0x17, 0xab, 0x68, 0x55, 0x52, 0xf9, 0x8a, 0xb9, 0x55, 0xa5, 0x60, 0xaa,
	0x6f, 0xd5, 0xec, 0xba, 0xf3, 0x13, 0x81, 0x1e, 0x0e, 0xfa, 0x57, 0xe2, 0xbb, 0xb5, 0x08, 0x5d,
	0x71, 0xe3, 0xea, 0x91, 0x9b, 0x56, 0x8f, 0x3a, 0xd0, 0x0b, 0xc5, 0x46, 0x2d, 0xf2, 0x79, 0xac,
	0x60, 0x0b, 0x3b, 0xa9, 0x52, 0x2f, 0x13, 0xcf, 0x9f, 0x98, 0xe1, 0x0d, 0x59, 0x1a, 0xce, 0x29,
	0x0c, 0xb2, 0xed, 0xc8, 0x61, 0xdd, 0xb0, 0x81, 0xef, 0xc3, 0x00, 0xf3, 0x16, 0x86, 0x47, 0x67,
	0x46, 0x38, 0x66, 0xcd, 0xf8, 0x6c, 0x07, 0x73, 0xf7, 0x01, 0x0a, 0xa1, 0x9a, 0xce, 0x29, 0xf4,
	0x70, 0x54, 0xf3, 0x4c, 0xe5, 0x31, 0xd4, 0x94, 0x0b, 0x63, 0x68, 0x58, 0xea, 0xba, 0x97, 0x59,
	0xea, 0x99, 0xe7, 0xb3, 0x5d, 0xcc, 0x64, 0x41, 0xb7, 0x14, 0xaa, 0xe5, 0xfc, 0x41, 0xa0, 0x8b,
	0x36, 0x87, 0xcc, 0x4f, 0xfb, 0x4c, 0x6d, 0x68, 0x32, 0xce, 0x63, 0x91, 0x24, 0x98, 0xa8, 0x3b,
	0x37, 0x62, 0xca, 0xf7, 0xb5, 0x0c, 0xcd, 0xa5, 0x8e, 0x9e, 0xce, 0xb9, 0x8a, 0x19, 0x67, 0x4b,
	0x5f, 0x64, 0x8f, 0x7b, 0x2e, 0xa7, 0x01, 0x63, 0xa1, 0xbc, 0x58, 0xf0, 0x6c, 0x41, 0x8c, 0x98,
	0x7a, 0x89, 0xc4, 0x8d, 0xe5, 0x4b, 0xc1, 0xcd, 0x76, 0x18, 0x79, 0xf6, 0x10, 0xf1, 0x1e, 0x00,
	0x05, 0x2b, 0xcb, 0x7f, 0x60, 0x92, 0xd3, 0x1d, 0xb0, 0xcc, 0xf9, 0x20, 0xbb, 0xb4, 0x88, 0xdd,
	0x76, 0x7e, 0x23, 0xd0, 0xd1, 0x85, 0x5b, 0x47, 0x91, 0x7f, 0x5e, 0x02, 0x4c, 0xca, 0x80, 0x3f,
	0x80, 0x81, 0x01, 0xb8, 0x60, 0x81, 0x5c, 0x87, 0x2a, 0x7b, 0xd8, 0xfa, 0x46, 0xfd, 0x18, 0xb5,
	0xf4, 0x3d, 0xe8, 0x67, 0x70, 0x8d, 0x9d, 0xe6, 0xd7, 0xcb, 0xb4, 0x99, 0xd9, 0x03, 0xb0, 0xdc,
	0xb4, 0x7c, 0xbe, 0x7f, 0x65, 0xa8, 0xd9, 0x0e, 0x72, 0xbd, 0x36, 0x2d, 0xf6, 0x3c, 0x47, 0x07,
	0xce, 0xf7, 0x19, 0xf4, 0x67, 0xb1, 0xb7, 0x3a, 0xde, 0xd0, 0x3b, 0x50, 0x57, 0x9b, 0xab, 0x66,
	0xd7, 0xd4, 0xe6, 0x88, 0x53, 0x0b, 0xaa, 0xea, 0x3c, 0xca, 0x80, 0xa6, 0x47, 0x7c, 0x94, 0xa5,
	0x32, 0x35, 0xc7, 0xf3, 0xad, 0x8f, 0xd2, 0x6c, 0x1b, 0x01, 0x74, 0xa0, 0x69, 0x72, 0x74, 0x0e,
	0x9f, 0xff, 0x7e, 0x31, 0x22, 0xaf, 0x2e, 0x46, 0xe4, 0x9f, 0x8b, 0x11, 0xf9, 0xf1, 0x72, 0xb4,
	0xf5, 0xea, 0x72, 0xb4, 0xf5, 0xd7, 0xe5, 0x68, 0xeb, 0xeb, 0x4f, 0x57, 0x9e, 0x3a, 0x59, 0x2f,
	0xc7, 0xae, 0x0c, 0x26, 0xf8, 0xb1, 0xf8, 0x28, 0x14, 0xea, 0xa5, 0x8c, 0xbf, 0xcd, 0x24, 0x5f,
	0xf0, 0x95, 0x88, 0x27, 0x9b, 0xc2, 0x7f, 0xc4, 0x95, 0xb1, 0x58, 0x36, 0xf0, 0x31, 0xf9, 0xf8,
	0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc4, 0x31, 0xcc, 0xb1, 0xae, 0x08, 0x00, 0x00,
}

func (m *CreditType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreditType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreditType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Precision != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Unit) > 0 {
		i -= len(m.Unit)
		copy(dAtA[i:], m.Unit)
		i = encodeVarintState(dAtA, i, uint64(len(m.Unit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintState(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Abbreviation) > 0 {
		i -= len(m.Abbreviation)
		copy(dAtA[i:], m.Abbreviation)
		i = encodeVarintState(dAtA, i, uint64(len(m.Abbreviation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClassInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CreditTypeAbbreviation) > 0 {
		i -= len(m.CreditTypeAbbreviation)
		copy(dAtA[i:], m.CreditTypeAbbreviation)
		i = encodeVarintState(dAtA, i, uint64(len(m.CreditTypeAbbreviation)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintState(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintState(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintState(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClassIssuer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassIssuer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassIssuer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClassId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintState(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProjectLocation) > 0 {
		i -= len(m.ProjectLocation)
		copy(dAtA[i:], m.ProjectLocation)
		i = encodeVarintState(dAtA, i, uint64(len(m.ProjectLocation)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ClassId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintState(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintState(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Open {
		i--
		if m.Open {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IssuanceDate != nil {
		{
			size, err := m.IssuanceDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.EndDate != nil {
		{
			size, err := m.EndDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.StartDate != nil {
		{
			size, err := m.StartDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintState(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintState(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x22
	}
	if m.ProjectId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ProjectId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClassSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextClassId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.NextClassId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CreditTypeAbbreviation) > 0 {
		i -= len(m.CreditTypeAbbreviation)
		copy(dAtA[i:], m.CreditTypeAbbreviation)
		i = encodeVarintState(dAtA, i, uint64(len(m.CreditTypeAbbreviation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProjectSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextProjectId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.NextProjectId))
		i--
		dAtA[i] = 0x10
	}
	if m.ClassId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.ClassId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextBatchId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.NextBatchId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintState(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchBalance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchBalance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Escrowed) > 0 {
		i -= len(m.Escrowed)
		copy(dAtA[i:], m.Escrowed)
		i = encodeVarintState(dAtA, i, uint64(len(m.Escrowed)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Retired) > 0 {
		i -= len(m.Retired)
		copy(dAtA[i:], m.Retired)
		i = encodeVarintState(dAtA, i, uint64(len(m.Retired)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tradable) > 0 {
		i -= len(m.Tradable)
		copy(dAtA[i:], m.Tradable)
		i = encodeVarintState(dAtA, i, uint64(len(m.Tradable)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BatchId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintState(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSupply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSupply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSupply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CancelledAmount) > 0 {
		i -= len(m.CancelledAmount)
		copy(dAtA[i:], m.CancelledAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.CancelledAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RetiredAmount) > 0 {
		i -= len(m.RetiredAmount)
		copy(dAtA[i:], m.RetiredAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.RetiredAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradableAmount) > 0 {
		i -= len(m.TradableAmount)
		copy(dAtA[i:], m.TradableAmount)
		i = encodeVarintState(dAtA, i, uint64(len(m.TradableAmount)))
		i--
		dAtA[i] = 0x12
	}
	if m.BatchId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchOrigTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchOrigTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchOrigTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintState(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Note) > 0 {
		i -= len(m.Note)
		copy(dAtA[i:], m.Note)
		i = encodeVarintState(dAtA, i, uint64(len(m.Note)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Typ) > 0 {
		i -= len(m.Typ)
		copy(dAtA[i:], m.Typ)
		i = encodeVarintState(dAtA, i, uint64(len(m.Typ)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintState(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintState(dAtA []byte, offset int, v uint64) int {
	offset -= sovState(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreditType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Abbreviation)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.Precision != 0 {
		n += 1 + sovState(uint64(m.Precision))
	}
	return n
}

func (m *ClassInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovState(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.CreditTypeAbbreviation)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *ClassIssuer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClassId != 0 {
		n += 1 + sovState(uint64(m.ClassId))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *ProjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovState(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.ClassId != 0 {
		n += 1 + sovState(uint64(m.ClassId))
	}
	l = len(m.ProjectLocation)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *BatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovState(uint64(m.Id))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.ProjectId != 0 {
		n += 1 + sovState(uint64(m.ProjectId))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.StartDate != nil {
		l = m.StartDate.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.EndDate != nil {
		l = m.EndDate.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.IssuanceDate != nil {
		l = m.IssuanceDate.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.Open {
		n += 2
	}
	return n
}

func (m *ClassSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CreditTypeAbbreviation)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.NextClassId != 0 {
		n += 1 + sovState(uint64(m.NextClassId))
	}
	return n
}

func (m *ProjectSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClassId != 0 {
		n += 1 + sovState(uint64(m.ClassId))
	}
	if m.NextProjectId != 0 {
		n += 1 + sovState(uint64(m.NextProjectId))
	}
	return n
}

func (m *BatchSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.NextBatchId != 0 {
		n += 1 + sovState(uint64(m.NextBatchId))
	}
	return n
}

func (m *BatchBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.BatchId != 0 {
		n += 1 + sovState(uint64(m.BatchId))
	}
	l = len(m.Tradable)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Retired)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Escrowed)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *BatchSupply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchId != 0 {
		n += 1 + sovState(uint64(m.BatchId))
	}
	l = len(m.TradableAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.RetiredAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.CancelledAmount)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func (m *BatchOrigTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Typ)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	return n
}

func sovState(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozState(x uint64) (n int) {
	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreditType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreditType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreditType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abbreviation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abbreviation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbreviation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbreviation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassIssuer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassIssuer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassIssuer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = append(m.Issuer[:0], dAtA[iNdEx:postIndex]...)
			if m.Issuer == nil {
				m.Issuer = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = append(m.Issuer[:0], dAtA[iNdEx:postIndex]...)
			if m.Issuer == nil {
				m.Issuer = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = &types.Timestamp{}
			}
			if err := m.StartDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndDate == nil {
				m.EndDate = &types.Timestamp{}
			}
			if err := m.EndDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuanceDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IssuanceDate == nil {
				m.IssuanceDate = &types.Timestamp{}
			}
			if err := m.IssuanceDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Open = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbreviation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbreviation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextClassId", wireType)
			}
			m.NextClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextClassId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextProjectId", wireType)
			}
			m.NextProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextProjectId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextBatchId", wireType)
			}
			m.NextBatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextBatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tradable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tradable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retired", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Retired = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Escrowed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Escrowed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSupply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSupply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSupply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetiredAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetiredAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchOrigTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchOrigTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchOrigTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Typ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipState(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowState
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthState
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupState
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthState
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthState        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowState          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupState = fmt.Errorf("proto: unexpected end of group")
)
