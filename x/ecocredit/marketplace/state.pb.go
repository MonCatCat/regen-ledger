// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/marketplace/v1/state.proto

package marketplace

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/api/cosmos/orm/v1alpha1"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SellOrder represents the information for a sell order.
type SellOrder struct {
	// id is the unique ID of sell order.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// seller is the bytes address of the owner of the credits being sold.
	Seller []byte `protobuf:"bytes,2,opt,name=seller,proto3" json:"seller,omitempty"`
	// batch_id is ID of the credit batch being sold.
	BatchId uint64 `protobuf:"varint,3,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// quantity is the decimal quantity of credits being sold.
	Quantity string `protobuf:"bytes,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// market_id is the market in which this sell order exists and specifies
	// the base_currency that ask_price corresponds to.
	MarketId uint64 `protobuf:"varint,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// ask_price is the integer price (encoded as a string) the seller is asking
	// for each unit of the batch_denom. Each credit unit of the batch will be
	// sold for at least the ask_price or more.
	AskPrice string `protobuf:"bytes,6,opt,name=ask_price,json=askPrice,proto3" json:"ask_price,omitempty"`
	// disable_auto_retire disables auto-retirement of credits which allows a
	// buyer to disable auto-retirement in their buy order enabling them to
	// resell the credits to another buyer.
	DisableAutoRetire bool `protobuf:"varint,7,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// expiration is an optional timestamp when the sell order expires. When the
	// expiration time is reached, the sell order is removed from state.
	Expiration *types.Timestamp `protobuf:"bytes,9,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// maker indicates that this is a maker order, meaning that when it hit
	// the order book, there were no matching buy orders.
	Maker bool `protobuf:"varint,10,opt,name=maker,proto3" json:"maker,omitempty"`
}

func (m *SellOrder) Reset()         { *m = SellOrder{} }
func (m *SellOrder) String() string { return proto.CompactTextString(m) }
func (*SellOrder) ProtoMessage()    {}
func (*SellOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_718b9cb8f10a9f3c, []int{0}
}
func (m *SellOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SellOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SellOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SellOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SellOrder.Merge(m, src)
}
func (m *SellOrder) XXX_Size() int {
	return m.Size()
}
func (m *SellOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_SellOrder.DiscardUnknown(m)
}

var xxx_messageInfo_SellOrder proto.InternalMessageInfo

func (m *SellOrder) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SellOrder) GetSeller() []byte {
	if m != nil {
		return m.Seller
	}
	return nil
}

func (m *SellOrder) GetBatchId() uint64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *SellOrder) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *SellOrder) GetMarketId() uint64 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *SellOrder) GetAskPrice() string {
	if m != nil {
		return m.AskPrice
	}
	return ""
}

func (m *SellOrder) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *SellOrder) GetExpiration() *types.Timestamp {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *SellOrder) GetMaker() bool {
	if m != nil {
		return m.Maker
	}
	return false
}

// BuyOrder represents the information for a buy order.
type BuyOrder struct {
	// id is the unique ID of buy order.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// buyer is the bytes address of the account that created the buy order
	Buyer []byte `protobuf:"bytes,2,opt,name=buyer,proto3" json:"buyer,omitempty"`
	// selection is the buy order selection.
	Selection *BuyOrder_Selection `protobuf:"bytes,3,opt,name=selection,proto3" json:"selection,omitempty"`
	// quantity is the decimal quantity of credits to buy. If the quantity of
	// credits available is less than this amount the order will be partially
	// filled unless disable_partial_fill is true.
	Quantity string `protobuf:"bytes,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// market_id is the market in which this sell order exists and specifies
	// the base_currency that ask_price corresponds to.
	MarketId uint64 `protobuf:"varint,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// bid price is the integer bid price for this buy order. A credit unit will
	// be settled at a purchase price that is no more than the bid price. The buy
	// order will fail if the buyer does not have enough funds available to
	// complete the purchase.
	BidPrice string `protobuf:"bytes,6,opt,name=bid_price,json=bidPrice,proto3" json:"bid_price,omitempty"`
	// disable_auto_retire allows auto-retirement to be disabled. If it is set to
	// true the credits will not auto-retire and can be resold assuming that the
	// corresponding sell order has auto-retirement disabled. If the sell order
	// hasn't disabled auto-retirement and the buy order tries to disable it,
	// that buy order will fail.
	DisableAutoRetire bool `protobuf:"varint,7,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// disable_partial_fill disables the default behavior of partially filling
	// buy orders if the requested quantity is not available.
	DisablePartialFill bool `protobuf:"varint,8,opt,name=disable_partial_fill,json=disablePartialFill,proto3" json:"disable_partial_fill,omitempty"`
	// expiration is the optional timestamp when the buy order expires. When the
	// expiration time is reached, the buy order is removed from state.
	Expiration *types.Timestamp `protobuf:"bytes,9,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// maker indicates that this is a maker order, meaning that when it hit
	// the order book, there were no matching sell orders.
	Maker bool `protobuf:"varint,10,opt,name=maker,proto3" json:"maker,omitempty"`
}

func (m *BuyOrder) Reset()         { *m = BuyOrder{} }
func (m *BuyOrder) String() string { return proto.CompactTextString(m) }
func (*BuyOrder) ProtoMessage()    {}
func (*BuyOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_718b9cb8f10a9f3c, []int{1}
}
func (m *BuyOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuyOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyOrder.Merge(m, src)
}
func (m *BuyOrder) XXX_Size() int {
	return m.Size()
}
func (m *BuyOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyOrder.DiscardUnknown(m)
}

var xxx_messageInfo_BuyOrder proto.InternalMessageInfo

func (m *BuyOrder) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BuyOrder) GetBuyer() []byte {
	if m != nil {
		return m.Buyer
	}
	return nil
}

func (m *BuyOrder) GetSelection() *BuyOrder_Selection {
	if m != nil {
		return m.Selection
	}
	return nil
}

func (m *BuyOrder) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *BuyOrder) GetMarketId() uint64 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *BuyOrder) GetBidPrice() string {
	if m != nil {
		return m.BidPrice
	}
	return ""
}

func (m *BuyOrder) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *BuyOrder) GetDisablePartialFill() bool {
	if m != nil {
		return m.DisablePartialFill
	}
	return false
}

func (m *BuyOrder) GetExpiration() *types.Timestamp {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *BuyOrder) GetMaker() bool {
	if m != nil {
		return m.Maker
	}
	return false
}

// Selection defines a buy order selection.
type BuyOrder_Selection struct {
	// sum defines the type of selection.
	//
	// Types that are valid to be assigned to Sum:
	//	*BuyOrder_Selection_SellOrderId
	//	*BuyOrder_Selection_Filter
	Sum isBuyOrder_Selection_Sum `protobuf_oneof:"sum"`
}

func (m *BuyOrder_Selection) Reset()         { *m = BuyOrder_Selection{} }
func (m *BuyOrder_Selection) String() string { return proto.CompactTextString(m) }
func (*BuyOrder_Selection) ProtoMessage()    {}
func (*BuyOrder_Selection) Descriptor() ([]byte, []int) {
	return fileDescriptor_718b9cb8f10a9f3c, []int{1, 0}
}
func (m *BuyOrder_Selection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyOrder_Selection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyOrder_Selection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuyOrder_Selection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyOrder_Selection.Merge(m, src)
}
func (m *BuyOrder_Selection) XXX_Size() int {
	return m.Size()
}
func (m *BuyOrder_Selection) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyOrder_Selection.DiscardUnknown(m)
}

var xxx_messageInfo_BuyOrder_Selection proto.InternalMessageInfo

type isBuyOrder_Selection_Sum interface {
	isBuyOrder_Selection_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BuyOrder_Selection_SellOrderId struct {
	SellOrderId uint64 `protobuf:"varint,1,opt,name=sell_order_id,json=sellOrderId,proto3,oneof" json:"sell_order_id,omitempty"`
}
type BuyOrder_Selection_Filter struct {
	Filter *Filter `protobuf:"bytes,2,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
}

func (*BuyOrder_Selection_SellOrderId) isBuyOrder_Selection_Sum() {}
func (*BuyOrder_Selection_Filter) isBuyOrder_Selection_Sum()      {}

func (m *BuyOrder_Selection) GetSum() isBuyOrder_Selection_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *BuyOrder_Selection) GetSellOrderId() uint64 {
	if x, ok := m.GetSum().(*BuyOrder_Selection_SellOrderId); ok {
		return x.SellOrderId
	}
	return 0
}

func (m *BuyOrder_Selection) GetFilter() *Filter {
	if x, ok := m.GetSum().(*BuyOrder_Selection_Filter); ok {
		return x.Filter
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BuyOrder_Selection) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BuyOrder_Selection_SellOrderId)(nil),
		(*BuyOrder_Selection_Filter)(nil),
	}
}

// AllowedDenom represents the information for an allowed ask/bid denom.
type AllowedDenom struct {
	// denom is the bank denom to allow (ex. ibc/GLKHDSG423SGS)
	BaseCurrency string `protobuf:"bytes,1,opt,name=base_currency,json=baseCurrency,proto3" json:"base_currency,omitempty"`
	// display_denom is the denom to display to the user and is informational.
	// Because the denom is likely an IBC denom, this should be chosen by
	// governance to represent the consensus trusted name of the denom.
	DisplayDenom string `protobuf:"bytes,2,opt,name=display_denom,json=displayDenom,proto3" json:"display_denom,omitempty"`
	// exponent is the exponent that relates the denom to the display_denom and is
	// informational
	Exponent uint32 `protobuf:"varint,3,opt,name=exponent,proto3" json:"exponent,omitempty"`
}

func (m *AllowedDenom) Reset()         { *m = AllowedDenom{} }
func (m *AllowedDenom) String() string { return proto.CompactTextString(m) }
func (*AllowedDenom) ProtoMessage()    {}
func (*AllowedDenom) Descriptor() ([]byte, []int) {
	return fileDescriptor_718b9cb8f10a9f3c, []int{2}
}
func (m *AllowedDenom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllowedDenom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllowedDenom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllowedDenom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowedDenom.Merge(m, src)
}
func (m *AllowedDenom) XXX_Size() int {
	return m.Size()
}
func (m *AllowedDenom) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowedDenom.DiscardUnknown(m)
}

var xxx_messageInfo_AllowedDenom proto.InternalMessageInfo

func (m *AllowedDenom) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *AllowedDenom) GetDisplayDenom() string {
	if m != nil {
		return m.DisplayDenom
	}
	return ""
}

func (m *AllowedDenom) GetExponent() uint32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

// Market describes a distinctly processed market between a credit type and
// allowed bank denom. Each market has its own precision in the order book
// and is processed independently of other markets. Governance must enable
// markets one by one. Every additional enabled market potentially adds more
// processing overhead to the blockchain and potentially weakens liquidity in
// competing markets. For instance, enabling side by side USD/Carbon and
// EUR/Carbon markets may have the end result that each market individually has
// less liquidity and longer settlement times. Such decisions should be taken
// with care.
type Market struct {
	// id is the unique ID of the market.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// credit_type is the abbreviation of the credit type.
	CreditType string `protobuf:"bytes,2,opt,name=credit_type,json=creditType,proto3" json:"credit_type,omitempty"`
	// base_currency is an allowed bank denom.
	BaseCurrency string `protobuf:"bytes,3,opt,name=base_currency,json=baseCurrency,proto3" json:"base_currency,omitempty"`
	// precision_modifier is an optional modifier used to convert arbitrary
	// precision integer bank amounts to uint32 values used for sorting in the
	// order book. Given an arbitrary precision integer x, its uint32 conversion
	// will be x / 10^precision_modifier using round half away from zero
	// rounding.
	//
	// uint32 values range from 0 to 4,294,967,295.
	// This allows for a full 9 digits of precision. In most real world markets
	// this amount of precision is sufficient and most common downside -
	// that some orders with very miniscule price differences may be ordered
	// equivalently (because of rounding) - is acceptable.
	// Note that this rounding will not affect settlement price which will
	// always be done exactly.
	//
	// Given a USD stable coin with 6 decimal digits, a precision_modifier
	// of 0 is probably acceptable as long as credits are always less than
	// $4,294/unit. With precision down to $0.001 (a precision_modifier of 3
	// in this case), prices can rise up to $4,294,000/unit. Either scenario
	// is probably quite acceptable given that carbon prices are unlikely to
	// rise above $1000/ton any time in the near future.
	//
	// If credit prices, exceed the maximum range of uint32 with this
	// precision_modifier, orders with high prices will fail and governance
	// will need to adjust precision_modifier to allow for higher prices in
	// exchange for less precision at the lower end.
	PrecisionModifier uint32 `protobuf:"varint,4,opt,name=precision_modifier,json=precisionModifier,proto3" json:"precision_modifier,omitempty"`
}

func (m *Market) Reset()         { *m = Market{} }
func (m *Market) String() string { return proto.CompactTextString(m) }
func (*Market) ProtoMessage()    {}
func (*Market) Descriptor() ([]byte, []int) {
	return fileDescriptor_718b9cb8f10a9f3c, []int{3}
}
func (m *Market) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Market) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Market.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Market) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Market.Merge(m, src)
}
func (m *Market) XXX_Size() int {
	return m.Size()
}
func (m *Market) XXX_DiscardUnknown() {
	xxx_messageInfo_Market.DiscardUnknown(m)
}

var xxx_messageInfo_Market proto.InternalMessageInfo

func (m *Market) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Market) GetCreditType() string {
	if m != nil {
		return m.CreditType
	}
	return ""
}

func (m *Market) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *Market) GetPrecisionModifier() uint32 {
	if m != nil {
		return m.PrecisionModifier
	}
	return 0
}

func init() {
	proto.RegisterType((*SellOrder)(nil), "regen.ecocredit.marketplace.v1.SellOrder")
	proto.RegisterType((*BuyOrder)(nil), "regen.ecocredit.marketplace.v1.BuyOrder")
	proto.RegisterType((*BuyOrder_Selection)(nil), "regen.ecocredit.marketplace.v1.BuyOrder.Selection")
	proto.RegisterType((*AllowedDenom)(nil), "regen.ecocredit.marketplace.v1.AllowedDenom")
	proto.RegisterType((*Market)(nil), "regen.ecocredit.marketplace.v1.Market")
}

func init() {
	proto.RegisterFile("regen/ecocredit/marketplace/v1/state.proto", fileDescriptor_718b9cb8f10a9f3c)
}

var fileDescriptor_718b9cb8f10a9f3c = []byte{
	// 761 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcb, 0x8e, 0xe3, 0x44,
	0x14, 0x4d, 0xe5, 0x35, 0x71, 0x25, 0x19, 0x32, 0x35, 0x2d, 0xe4, 0x09, 0x22, 0x1d, 0x85, 0x87,
	0x22, 0x86, 0xb1, 0x49, 0xc3, 0x2a, 0x12, 0x12, 0xd3, 0xa0, 0xd1, 0xf4, 0x62, 0x44, 0xcb, 0x33,
	0x12, 0x12, 0x1b, 0xab, 0xec, 0xba, 0x49, 0x97, 0x52, 0x76, 0x99, 0x72, 0xb9, 0xbb, 0xc3, 0x47,
	0x20, 0xbe, 0x80, 0x15, 0xbf, 0xc0, 0x9e, 0x25, 0xcb, 0x96, 0xd8, 0xb0, 0x44, 0xe9, 0x3f, 0xe0,
	0x0b, 0x90, 0xcb, 0x76, 0x3a, 0xfd, 0x10, 0x2d, 0x01, 0xcb, 0x5b, 0xf7, 0xdc, 0x5b, 0xa7, 0xce,
	0x39, 0x36, 0xfe, 0x48, 0xc1, 0x12, 0x62, 0x17, 0x42, 0x19, 0x2a, 0x60, 0x5c, 0xbb, 0x11, 0x55,
	0x2b, 0xd0, 0x89, 0xa0, 0x21, 0xb8, 0xa7, 0x33, 0x37, 0xd5, 0x54, 0x83, 0x93, 0x28, 0xa9, 0x25,
	0x19, 0x19, 0xac, 0xb3, 0xc5, 0x3a, 0x3b, 0x58, 0xe7, 0x74, 0x36, 0xdc, 0x5f, 0x4a, 0xb9, 0x14,
	0xe0, 0x1a, 0x74, 0x90, 0x2d, 0x5c, 0xcd, 0x23, 0x48, 0x35, 0x8d, 0x92, 0x62, 0xc1, 0xf0, 0xdd,
	0x50, 0xa6, 0x91, 0x4c, 0x5d, 0xa9, 0x22, 0xf7, 0x74, 0x46, 0x45, 0x72, 0x42, 0x67, 0x79, 0x51,
	0xb6, 0xef, 0xe3, 0xa2, 0xd7, 0x09, 0xa4, 0x05, 0x76, 0xb2, 0xa9, 0x63, 0xeb, 0x35, 0x08, 0xf1,
	0xb5, 0x62, 0xa0, 0xc8, 0x43, 0x5c, 0xe7, 0xcc, 0x46, 0x63, 0x34, 0x6d, 0x7a, 0x75, 0xce, 0xc8,
	0xdb, 0xb8, 0x9d, 0x82, 0x10, 0xa0, 0xec, 0xfa, 0x18, 0x4d, 0x7b, 0x5e, 0x59, 0x91, 0x27, 0xb8,
	0x13, 0x50, 0x1d, 0x9e, 0xf8, 0x9c, 0xd9, 0x0d, 0x83, 0x7e, 0x60, 0xea, 0x23, 0x46, 0x86, 0xb8,
	0xf3, 0x5d, 0x46, 0x63, 0xcd, 0xf5, 0xda, 0x6e, 0x8e, 0xd1, 0xd4, 0xf2, 0xb6, 0x35, 0x79, 0x07,
	0x5b, 0x05, 0x95, 0x7c, 0xae, 0x65, 0xe6, 0x3a, 0xc5, 0xc1, 0x11, 0xcb, 0x9b, 0x34, 0x5d, 0xf9,
	0x89, 0xe2, 0x21, 0xd8, 0xed, 0x62, 0x92, 0xa6, 0xab, 0xe3, 0xbc, 0x26, 0x0e, 0x7e, 0xcc, 0x78,
	0x4a, 0x03, 0x01, 0x3e, 0xcd, 0xb4, 0xf4, 0x15, 0x68, 0xae, 0xc0, 0x7e, 0x30, 0x46, 0xd3, 0x8e,
	0xf7, 0xa8, 0x6c, 0x3d, 0xcf, 0xb4, 0xf4, 0x4c, 0x83, 0xcc, 0x31, 0x86, 0xf3, 0x84, 0x2b, 0xaa,
	0xb9, 0x8c, 0x6d, 0x6b, 0x8c, 0xa6, 0xdd, 0x83, 0xa1, 0x53, 0xe8, 0xea, 0x54, 0xba, 0x3a, 0x6f,
	0x2a, 0x5d, 0xbd, 0x1d, 0x34, 0xd9, 0xc3, 0xad, 0x88, 0xae, 0x40, 0xd9, 0xd8, 0x6c, 0x2f, 0x8a,
	0xf9, 0xfc, 0xaf, 0x9f, 0x7e, 0xff, 0xa1, 0xf1, 0x19, 0x6e, 0xe7, 0x12, 0x0d, 0x10, 0xe9, 0x5d,
	0x49, 0x30, 0x40, 0x04, 0x57, 0x42, 0x0d, 0xea, 0xe4, 0xe1, 0xee, 0xdd, 0x83, 0x86, 0x8d, 0x26,
	0xbf, 0x34, 0x71, 0xe7, 0x30, 0x5b, 0xdf, 0xad, 0xf1, 0x1e, 0x6e, 0x05, 0xd9, 0x7a, 0x2b, 0x71,
	0x51, 0x90, 0x63, 0x6c, 0xa5, 0x20, 0x20, 0x34, 0xfc, 0x1b, 0x86, 0xff, 0x81, 0xf3, 0xcf, 0xb9,
	0x71, 0xaa, 0x2b, 0x9c, 0xd7, 0xd5, 0xa4, 0x77, 0xb5, 0xe4, 0x3f, 0x19, 0x13, 0x70, 0x76, 0xdd,
	0x98, 0x80, 0xb3, 0x7f, 0x67, 0xcc, 0x27, 0x78, 0xaf, 0xc2, 0x27, 0x54, 0x69, 0x4e, 0x85, 0xbf,
	0xe0, 0x42, 0xd8, 0x1d, 0x33, 0x40, 0xca, 0xde, 0x71, 0xd1, 0x7a, 0xc1, 0x85, 0xf8, 0xff, 0xad,
	0x1c, 0x7e, 0x6f, 0x22, 0x5f, 0xca, 0xf2, 0x3e, 0xee, 0xe7, 0xce, 0xf9, 0x32, 0x57, 0xce, 0xaf,
	0x9c, 0x79, 0x59, 0xf3, 0xba, 0x69, 0xf5, 0x59, 0x1c, 0x31, 0xf2, 0x05, 0x6e, 0x2f, 0xb8, 0xd0,
	0xa5, 0x4b, 0xdd, 0x83, 0x0f, 0xef, 0xf3, 0xe2, 0x85, 0x41, 0xbf, 0xac, 0x79, 0xe5, 0xdc, 0x61,
	0x0b, 0x37, 0xd2, 0x2c, 0x9a, 0x3f, 0x35, 0x31, 0xfa, 0x60, 0x1b, 0x23, 0xab, 0x74, 0x7f, 0x80,
	0x6e, 0xe4, 0xa6, 0x6e, 0xd7, 0x27, 0x3f, 0x23, 0xdc, 0x7b, 0x2e, 0x84, 0x3c, 0x03, 0xf6, 0x15,
	0xc4, 0x32, 0x22, 0xef, 0xe1, 0x7e, 0x40, 0x53, 0xf0, 0xc3, 0x4c, 0x29, 0x88, 0xc3, 0xb5, 0x21,
	0x6b, 0x79, 0xbd, 0xfc, 0xf0, 0xcb, 0xf2, 0x2c, 0x07, 0x31, 0x9e, 0x26, 0x82, 0xae, 0x7d, 0x96,
	0x4f, 0x19, 0xca, 0x96, 0xd7, 0x2b, 0x0f, 0x8b, 0x4d, 0x43, 0xdc, 0x81, 0xf3, 0x44, 0xc6, 0x10,
	0x6b, 0x13, 0xaf, 0xbe, 0xb7, 0xad, 0xe7, 0x8e, 0xe1, 0x38, 0xc5, 0x6f, 0xdd, 0xb8, 0x8d, 0x3c,
	0xbe, 0xb1, 0x79, 0x80, 0x6c, 0x64, 0x37, 0x26, 0xbf, 0x22, 0xdc, 0x7e, 0x65, 0x9e, 0x7f, 0x2b,
	0xdc, 0xfb, 0xb8, 0x5b, 0xe8, 0xe3, 0xe7, 0x3f, 0x9d, 0x92, 0x09, 0x2e, 0x8e, 0xde, 0xac, 0x13,
	0xb8, 0xfd, 0xa2, 0xc6, 0x1d, 0x2f, 0x7a, 0x86, 0x49, 0xa2, 0x20, 0xe4, 0x29, 0x97, 0xb1, 0x1f,
	0x49, 0xc6, 0x17, 0x1c, 0x94, 0x09, 0x71, 0xdf, 0x7b, 0xb4, 0xed, 0xbc, 0x2a, 0x1b, 0xf3, 0x99,
	0xe1, 0xff, 0x74, 0xab, 0xf1, 0x3e, 0x7e, 0xb2, 0x43, 0xe2, 0xe3, 0x6b, 0xf7, 0x99, 0x27, 0x34,
	0x0f, 0xbf, 0xf9, 0x6d, 0x33, 0x42, 0x17, 0x9b, 0x11, 0xfa, 0x73, 0x33, 0x42, 0x3f, 0x5e, 0x8e,
	0x6a, 0x17, 0x97, 0xa3, 0xda, 0x1f, 0x97, 0xa3, 0xda, 0xb7, 0x9f, 0x2f, 0xb9, 0x3e, 0xc9, 0x02,
	0x27, 0x94, 0x91, 0x6b, 0x3c, 0x7f, 0x16, 0x83, 0x3e, 0x93, 0x6a, 0x55, 0x56, 0x02, 0xd8, 0x12,
	0x94, 0x7b, 0x7e, 0xf7, 0xef, 0x36, 0x68, 0x9b, 0x84, 0x7e, 0xfa, 0x77, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x93, 0x1c, 0x34, 0xcd, 0x20, 0x06, 0x00, 0x00,
}

func (m *SellOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SellOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SellOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Maker {
		i--
		if m.Maker {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Expiration != nil {
		{
			size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.AskPrice) > 0 {
		i -= len(m.AskPrice)
		copy(dAtA[i:], m.AskPrice)
		i = encodeVarintState(dAtA, i, uint64(len(m.AskPrice)))
		i--
		dAtA[i] = 0x32
	}
	if m.MarketId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintState(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x22
	}
	if m.BatchId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Seller) > 0 {
		i -= len(m.Seller)
		copy(dAtA[i:], m.Seller)
		i = encodeVarintState(dAtA, i, uint64(len(m.Seller)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuyOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuyOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Maker {
		i--
		if m.Maker {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Expiration != nil {
		{
			size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DisablePartialFill {
		i--
		if m.DisablePartialFill {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.BidPrice) > 0 {
		i -= len(m.BidPrice)
		copy(dAtA[i:], m.BidPrice)
		i = encodeVarintState(dAtA, i, uint64(len(m.BidPrice)))
		i--
		dAtA[i] = 0x32
	}
	if m.MarketId != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Quantity) > 0 {
		i -= len(m.Quantity)
		copy(dAtA[i:], m.Quantity)
		i = encodeVarintState(dAtA, i, uint64(len(m.Quantity)))
		i--
		dAtA[i] = 0x22
	}
	if m.Selection != nil {
		{
			size, err := m.Selection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintState(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuyOrder_Selection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyOrder_Selection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuyOrder_Selection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BuyOrder_Selection_SellOrderId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuyOrder_Selection_SellOrderId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintState(dAtA, i, uint64(m.SellOrderId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *BuyOrder_Selection_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuyOrder_Selection_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintState(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AllowedDenom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowedDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowedDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exponent != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DisplayDenom) > 0 {
		i -= len(m.DisplayDenom)
		copy(dAtA[i:], m.DisplayDenom)
		i = encodeVarintState(dAtA, i, uint64(len(m.DisplayDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BaseCurrency) > 0 {
		i -= len(m.BaseCurrency)
		copy(dAtA[i:], m.BaseCurrency)
		i = encodeVarintState(dAtA, i, uint64(len(m.BaseCurrency)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Market) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Market) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Market) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrecisionModifier != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.PrecisionModifier))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BaseCurrency) > 0 {
		i -= len(m.BaseCurrency)
		copy(dAtA[i:], m.BaseCurrency)
		i = encodeVarintState(dAtA, i, uint64(len(m.BaseCurrency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CreditType) > 0 {
		i -= len(m.CreditType)
		copy(dAtA[i:], m.CreditType)
		i = encodeVarintState(dAtA, i, uint64(len(m.CreditType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintState(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintState(dAtA []byte, offset int, v uint64) int {
	offset -= sovState(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SellOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovState(uint64(m.Id))
	}
	l = len(m.Seller)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.BatchId != 0 {
		n += 1 + sovState(uint64(m.BatchId))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovState(uint64(m.MarketId))
	}
	l = len(m.AskPrice)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.Maker {
		n += 2
	}
	return n
}

func (m *BuyOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovState(uint64(m.Id))
	}
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.Selection != nil {
		l = m.Selection.Size()
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovState(uint64(m.MarketId))
	}
	l = len(m.BidPrice)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	if m.DisablePartialFill {
		n += 2
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovState(uint64(l))
	}
	if m.Maker {
		n += 2
	}
	return n
}

func (m *BuyOrder_Selection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *BuyOrder_Selection_SellOrderId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovState(uint64(m.SellOrderId))
	return n
}
func (m *BuyOrder_Selection_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovState(uint64(l))
	}
	return n
}
func (m *AllowedDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseCurrency)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.DisplayDenom)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovState(uint64(m.Exponent))
	}
	return n
}

func (m *Market) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovState(uint64(m.Id))
	}
	l = len(m.CreditType)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	l = len(m.BaseCurrency)
	if l > 0 {
		n += 1 + l + sovState(uint64(l))
	}
	if m.PrecisionModifier != 0 {
		n += 1 + sovState(uint64(m.PrecisionModifier))
	}
	return n
}

func sovState(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozState(x uint64) (n int) {
	return sovState(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SellOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SellOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SellOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seller = append(m.Seller[:0], dAtA[iNdEx:postIndex]...)
			if m.Seller == nil {
				m.Seller = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AskPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &types.Timestamp{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maker", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Maker = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = append(m.Buyer[:0], dAtA[iNdEx:postIndex]...)
			if m.Buyer == nil {
				m.Buyer = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selection == nil {
				m.Selection = &BuyOrder_Selection{}
			}
			if err := m.Selection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BidPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePartialFill", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisablePartialFill = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &types.Timestamp{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maker", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Maker = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyOrder_Selection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Selection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Selection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellOrderId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sum = &BuyOrder_Selection_SellOrderId{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &BuyOrder_Selection_Filter{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowedDenom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowedDenom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowedDenom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Market) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowState
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Market: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Market: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthState
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthState
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrecisionModifier", wireType)
			}
			m.PrecisionModifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowState
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrecisionModifier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipState(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthState
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipState(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowState
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowState
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthState
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupState
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthState
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthState        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowState          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupState = fmt.Errorf("proto: unexpected end of group")
)
