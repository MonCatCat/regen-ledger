// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/basket/v1/tx.proto

package basket

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateBasket is the Msg/CreateBasket request type.
type MsgCreate struct {
	// curator is the address of the basket curator who is able to change certain
	// basket settings.
	Curator string `protobuf:"bytes,1,opt,name=curator,proto3" json:"curator,omitempty"`
	// name will be used to together with prefix to create a bank denom for this
	// basket token. It can be between 3-8 alphanumeric characters, with the
	// first character being alphabetic.
	//
	// The bank denom will be formed from name, credit type and exponent and be
	// of the form `eco.<prefix><credit_type_abbrev>.<name>` where prefix
	// is derived from exponent.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// description is a human-readable description of the basket denom that should
	// be at most 256 characters.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// exponent is the exponent that will be used for converting credits to basket
	// tokens and for bank denom metadata. It also limits the precision of
	// credit amounts when putting credits into a basket. An exponent of 6 will
	// mean that 10^6 units of a basket token will be issued for 1.0 credits and that
	// this should be displayed as one unit in user interfaces. It also means
	// that the maximum precision of credit amounts is 6 decimal places so that
	// the need to round is eliminated. The exponent must be >= the precision of
	// the credit type at the time the basket is created and be of one of the
	// following values 0, 1, 2, 3, 6, 9, 12, 15, 18, 21, or 24 which correspond
	// to the exponents which have an official SI prefix.
	//
	// The exponent will be used to form the prefix part of the the bank denom
	// and will be mapped as follows:
	//   0 - no prefix
	//   1 - d (deci)
	//   2 - c (centi)
	//   3 - m (milli)
	//   6 - u (micro)
	//   9 - n (nano)
	//   12 - p (pico)
	//   15 - f (femto)
	//   18 - a (atto)
	//   21 - z (zepto)
	//   24 - y (yocto)
	Exponent uint32 `protobuf:"varint,4,opt,name=exponent,proto3" json:"exponent,omitempty"`
	// disable_auto_retire allows auto-retirement to be disabled.
	// The credits will be auto-retired if disable_auto_retire is
	// false unless the credits were previously put into the basket by the
	// address picking them from the basket, in which case they will remain
	// tradable.
	DisableAutoRetire bool `protobuf:"varint,5,opt,name=disable_auto_retire,json=disableAutoRetire,proto3" json:"disable_auto_retire,omitempty"`
	// credit_type_abbrev is the abbreviation of the credit type this basket is
	// able to hold.
	CreditTypeAbbrev string `protobuf:"bytes,6,opt,name=credit_type_abbrev,json=creditTypeAbbrev,proto3" json:"credit_type_abbrev,omitempty"`
	// allowed_classes are the credit classes allowed to be put in the basket
	AllowedClasses []string `protobuf:"bytes,7,rep,name=allowed_classes,json=allowedClasses,proto3" json:"allowed_classes,omitempty"`
	// date_criteria is the date criteria for batches admitted to the basket.
	// At most, only one of the fields in the date_criteria should be set.
	DateCriteria *DateCriteria `protobuf:"bytes,8,opt,name=date_criteria,json=dateCriteria,proto3" json:"date_criteria,omitempty"`
	// fee is the fee that the curator will pay to create the basket. It must be
	// >= the required Params.basket_creation_fee. We include the fee explicitly
	// here so that the curator explicitly acknowledges paying this fee and
	// is not surprised to learn that the paid a big fee and didn't know
	// beforehand.
	Fee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,9,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
}

func (m *MsgCreate) Reset()         { *m = MsgCreate{} }
func (m *MsgCreate) String() string { return proto.CompactTextString(m) }
func (*MsgCreate) ProtoMessage()    {}
func (*MsgCreate) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{0}
}
func (m *MsgCreate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreate.Merge(m, src)
}
func (m *MsgCreate) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreate) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreate.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreate proto.InternalMessageInfo

func (m *MsgCreate) GetCurator() string {
	if m != nil {
		return m.Curator
	}
	return ""
}

func (m *MsgCreate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreate) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreate) GetExponent() uint32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

func (m *MsgCreate) GetDisableAutoRetire() bool {
	if m != nil {
		return m.DisableAutoRetire
	}
	return false
}

func (m *MsgCreate) GetCreditTypeAbbrev() string {
	if m != nil {
		return m.CreditTypeAbbrev
	}
	return ""
}

func (m *MsgCreate) GetAllowedClasses() []string {
	if m != nil {
		return m.AllowedClasses
	}
	return nil
}

func (m *MsgCreate) GetDateCriteria() *DateCriteria {
	if m != nil {
		return m.DateCriteria
	}
	return nil
}

func (m *MsgCreate) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

// MsgCreateBasketResponse is the Msg/CreateBasket response type.
type MsgCreateResponse struct {
	// basket_denom is the unique denomination ID of the newly created basket.
	BasketDenom string `protobuf:"bytes,1,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
}

func (m *MsgCreateResponse) Reset()         { *m = MsgCreateResponse{} }
func (m *MsgCreateResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateResponse) ProtoMessage()    {}
func (*MsgCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{1}
}
func (m *MsgCreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateResponse.Merge(m, src)
}
func (m *MsgCreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateResponse proto.InternalMessageInfo

func (m *MsgCreateResponse) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

// MsgAddToBasket is the Msg/AddToBasket request type.
type MsgPut struct {
	// owner is the owner of credits being put into the basket.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket denom to add credits to.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// credits are credits to add to the basket. If they do not match the basket's
	// admission criteria the operation will fail. If there are any "dust" credits
	// left over when converting credits to basket tokens, these credits will
	// not be converted to basket tokens and instead remain with the owner.
	Credits []*BasketCredit `protobuf:"bytes,3,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgPut) Reset()         { *m = MsgPut{} }
func (m *MsgPut) String() string { return proto.CompactTextString(m) }
func (*MsgPut) ProtoMessage()    {}
func (*MsgPut) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{2}
}
func (m *MsgPut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPut.Merge(m, src)
}
func (m *MsgPut) XXX_Size() int {
	return m.Size()
}
func (m *MsgPut) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPut.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPut proto.InternalMessageInfo

func (m *MsgPut) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgPut) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgPut) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgAddToBasketResponse is the Msg/AddToBasket response type.
type MsgPutResponse struct {
	// amount_received is the integer amount of basket tokens received.
	AmountReceived string `protobuf:"bytes,1,opt,name=amount_received,json=amountReceived,proto3" json:"amount_received,omitempty"`
}

func (m *MsgPutResponse) Reset()         { *m = MsgPutResponse{} }
func (m *MsgPutResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPutResponse) ProtoMessage()    {}
func (*MsgPutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{3}
}
func (m *MsgPutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPutResponse.Merge(m, src)
}
func (m *MsgPutResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPutResponse proto.InternalMessageInfo

func (m *MsgPutResponse) GetAmountReceived() string {
	if m != nil {
		return m.AmountReceived
	}
	return ""
}

// MsgTakeFromBasket is the Msg/TakeFromBasket request type.
type MsgTake struct {
	// owner is the owner of the basket tokens.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// basket_denom is the basket bank denom to take credits from.
	BasketDenom string `protobuf:"bytes,2,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// amount is the integer number of basket tokens to convert into credits.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// retirement_location is the optional retirement location for the credits
	// which will be used only if retire_on_take is true for this basket.
	RetirementLocation string `protobuf:"bytes,4,opt,name=retirement_location,json=retirementLocation,proto3" json:"retirement_location,omitempty"`
	// retire_on_take is a boolean that dictates whether the ecocredits
	// received in exchange for the basket tokens will be received as
	// retired or tradable credits.
	RetireOnTake bool `protobuf:"varint,5,opt,name=retire_on_take,json=retireOnTake,proto3" json:"retire_on_take,omitempty"`
}

func (m *MsgTake) Reset()         { *m = MsgTake{} }
func (m *MsgTake) String() string { return proto.CompactTextString(m) }
func (*MsgTake) ProtoMessage()    {}
func (*MsgTake) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{4}
}
func (m *MsgTake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTake.Merge(m, src)
}
func (m *MsgTake) XXX_Size() int {
	return m.Size()
}
func (m *MsgTake) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTake.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTake proto.InternalMessageInfo

func (m *MsgTake) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgTake) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *MsgTake) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *MsgTake) GetRetirementLocation() string {
	if m != nil {
		return m.RetirementLocation
	}
	return ""
}

func (m *MsgTake) GetRetireOnTake() bool {
	if m != nil {
		return m.RetireOnTake
	}
	return false
}

// MsgTakeFromBasketResponse is the Msg/TakeFromBasket response type.
type MsgTakeResponse struct {
	// credits are the credits taken out of the basket.
	Credits []*BasketCredit `protobuf:"bytes,1,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *MsgTakeResponse) Reset()         { *m = MsgTakeResponse{} }
func (m *MsgTakeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTakeResponse) ProtoMessage()    {}
func (*MsgTakeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{5}
}
func (m *MsgTakeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTakeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTakeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTakeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTakeResponse.Merge(m, src)
}
func (m *MsgTakeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTakeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTakeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTakeResponse proto.InternalMessageInfo

func (m *MsgTakeResponse) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

// MsgUpdateBasketFeeRequest is the Msg/UpdateBasketFee request type.
type MsgUpdateBasketFeeRequest struct {
	// root_address is the address of the caller.
	// this MUST equal the address of the gov module for the tx to succeed.
	RootAddress string `protobuf:"bytes,1,opt,name=root_address,json=rootAddress,proto3" json:"root_address,omitempty"`
	// add_fees are the coin denoms and amounts to be added to the allowed basket creation fees.
	AddFees []*types.Coin `protobuf:"bytes,2,rep,name=add_fees,json=addFees,proto3" json:"add_fees,omitempty"`
	// remove_denoms are the coin denoms to be removed from the allowed basket creation fees.
	RemoveDenoms []string `protobuf:"bytes,3,rep,name=remove_denoms,json=removeDenoms,proto3" json:"remove_denoms,omitempty"`
}

func (m *MsgUpdateBasketFeeRequest) Reset()         { *m = MsgUpdateBasketFeeRequest{} }
func (m *MsgUpdateBasketFeeRequest) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBasketFeeRequest) ProtoMessage()    {}
func (*MsgUpdateBasketFeeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{6}
}
func (m *MsgUpdateBasketFeeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBasketFeeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBasketFeeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBasketFeeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBasketFeeRequest.Merge(m, src)
}
func (m *MsgUpdateBasketFeeRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBasketFeeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBasketFeeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBasketFeeRequest proto.InternalMessageInfo

func (m *MsgUpdateBasketFeeRequest) GetRootAddress() string {
	if m != nil {
		return m.RootAddress
	}
	return ""
}

func (m *MsgUpdateBasketFeeRequest) GetAddFees() []*types.Coin {
	if m != nil {
		return m.AddFees
	}
	return nil
}

func (m *MsgUpdateBasketFeeRequest) GetRemoveDenoms() []string {
	if m != nil {
		return m.RemoveDenoms
	}
	return nil
}

// MsgUpdateBasketFeeResponse is the Msg/UpdateBasketFee response type.
type MsgUpdateBasketFeeResponse struct {
}

func (m *MsgUpdateBasketFeeResponse) Reset()         { *m = MsgUpdateBasketFeeResponse{} }
func (m *MsgUpdateBasketFeeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateBasketFeeResponse) ProtoMessage()    {}
func (*MsgUpdateBasketFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a60f962a3c61f018, []int{7}
}
func (m *MsgUpdateBasketFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateBasketFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateBasketFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateBasketFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateBasketFeeResponse.Merge(m, src)
}
func (m *MsgUpdateBasketFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateBasketFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateBasketFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateBasketFeeResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgCreate)(nil), "regen.ecocredit.basket.v1.MsgCreate")
	proto.RegisterType((*MsgCreateResponse)(nil), "regen.ecocredit.basket.v1.MsgCreateResponse")
	proto.RegisterType((*MsgPut)(nil), "regen.ecocredit.basket.v1.MsgPut")
	proto.RegisterType((*MsgPutResponse)(nil), "regen.ecocredit.basket.v1.MsgPutResponse")
	proto.RegisterType((*MsgTake)(nil), "regen.ecocredit.basket.v1.MsgTake")
	proto.RegisterType((*MsgTakeResponse)(nil), "regen.ecocredit.basket.v1.MsgTakeResponse")
	proto.RegisterType((*MsgUpdateBasketFeeRequest)(nil), "regen.ecocredit.basket.v1.MsgUpdateBasketFeeRequest")
	proto.RegisterType((*MsgUpdateBasketFeeResponse)(nil), "regen.ecocredit.basket.v1.MsgUpdateBasketFeeResponse")
}

func init() {
	proto.RegisterFile("regen/ecocredit/basket/v1/tx.proto", fileDescriptor_a60f962a3c61f018)
}

var fileDescriptor_a60f962a3c61f018 = []byte{
	// 791 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcd, 0x8e, 0xdb, 0x54,
	0x14, 0x8e, 0xc7, 0x69, 0x7e, 0x6e, 0x66, 0x32, 0xf4, 0xb6, 0x42, 0x1e, 0x0b, 0xa5, 0xa9, 0x29,
	0x6a, 0x40, 0xad, 0x4d, 0x86, 0x82, 0x60, 0x99, 0x49, 0xd5, 0x55, 0x23, 0x2a, 0x33, 0xb0, 0x40,
	0x20, 0xeb, 0xc6, 0xf7, 0xd4, 0x58, 0x49, 0x7c, 0xc3, 0xbd, 0xd7, 0x99, 0xe9, 0x86, 0x15, 0x0f,
	0xd0, 0x2d, 0xaf, 0x00, 0x2b, 0xde, 0xa2, 0xcb, 0x59, 0xb2, 0x02, 0x34, 0xf3, 0x22, 0xe8, 0xfe,
	0xc4, 0x44, 0xcc, 0x90, 0x81, 0x59, 0xc5, 0xe7, 0x3b, 0xdf, 0x39, 0x39, 0xe7, 0x3b, 0x9f, 0x6c,
	0x14, 0x70, 0xc8, 0xa0, 0x88, 0x20, 0x65, 0x29, 0x07, 0x9a, 0xcb, 0x68, 0x4a, 0xc4, 0x0c, 0x64,
	0xb4, 0x1a, 0x46, 0xf2, 0x34, 0x5c, 0x72, 0x26, 0x19, 0x3e, 0xd0, 0x9c, 0xb0, 0xe2, 0x84, 0x86,
	0x13, 0xae, 0x86, 0xfe, 0xdd, 0x8c, 0x65, 0x4c, 0xb3, 0x22, 0xf5, 0x64, 0x0a, 0xfc, 0xf7, 0xb6,
	0x34, 0x7d, 0xb5, 0x04, 0x61, 0x69, 0xbd, 0x94, 0x89, 0x05, 0x13, 0x2a, 0x0b, 0xd1, 0x6a, 0x38,
	0x05, 0x49, 0x86, 0x51, 0xca, 0xf2, 0xc2, 0xe4, 0x83, 0x5f, 0x5c, 0xd4, 0x9e, 0x88, 0x6c, 0xcc,
	0x81, 0x48, 0xc0, 0x1e, 0x6a, 0xa6, 0x25, 0x27, 0x92, 0x71, 0xcf, 0xe9, 0x3b, 0x83, 0x76, 0xbc,
	0x0e, 0x31, 0x46, 0xf5, 0x82, 0x2c, 0xc0, 0xdb, 0xd1, 0xb0, 0x7e, 0xc6, 0x7d, 0xd4, 0xa1, 0x20,
	0x52, 0x9e, 0x2f, 0x65, 0xce, 0x0a, 0xcf, 0xd5, 0xa9, 0x4d, 0x08, 0xfb, 0xa8, 0x05, 0xa7, 0x4b,
	0x56, 0x40, 0x21, 0xbd, 0x7a, 0xdf, 0x19, 0xec, 0xc5, 0x55, 0x8c, 0x43, 0x74, 0x87, 0xe6, 0x82,
	0x4c, 0xe7, 0x90, 0x90, 0x52, 0xb2, 0x84, 0x83, 0xcc, 0x39, 0x78, 0xb7, 0xfa, 0xce, 0xa0, 0x15,
	0xdf, 0xb6, 0xa9, 0x51, 0x29, 0x59, 0xac, 0x13, 0xf8, 0x11, 0xc2, 0x66, 0xd3, 0x44, 0xed, 0x97,
	0x90, 0xe9, 0x94, 0xc3, 0xca, 0x6b, 0xe8, 0x3f, 0x7d, 0xcb, 0x64, 0x8e, 0x5f, 0x2d, 0x61, 0xa4,
	0x71, 0xfc, 0x10, 0xed, 0x93, 0xf9, 0x9c, 0x9d, 0x00, 0x4d, 0xd2, 0x39, 0x11, 0x02, 0x84, 0xd7,
	0xec, 0xbb, 0x83, 0x76, 0xdc, 0xb5, 0xf0, 0xd8, 0xa0, 0xf8, 0x39, 0xda, 0xa3, 0x44, 0x42, 0x92,
	0xf2, 0x5c, 0x02, 0xcf, 0x89, 0xd7, 0xea, 0x3b, 0x83, 0xce, 0xe1, 0xc3, 0xf0, 0x5f, 0x0f, 0x12,
	0x3e, 0x25, 0x12, 0xc6, 0x96, 0x1e, 0xef, 0xd2, 0x8d, 0x08, 0x7f, 0x8b, 0xdc, 0x97, 0x00, 0x5e,
	0xbb, 0xef, 0x0e, 0x3a, 0x87, 0x07, 0xa1, 0x11, 0x5f, 0x95, 0x42, 0x68, 0xc5, 0x0f, 0xc7, 0x2c,
	0x2f, 0x8e, 0x3e, 0x7c, 0xf3, 0xfb, 0xbd, 0xda, 0xcf, 0x7f, 0xdc, 0x1b, 0x64, 0xb9, 0xfc, 0xae,
	0x9c, 0x86, 0x29, 0x5b, 0x44, 0xf6, 0x52, 0xe6, 0xe7, 0xb1, 0xa0, 0x33, 0x7b, 0x48, 0x55, 0x20,
	0x62, 0xd5, 0x37, 0xf8, 0x04, 0xdd, 0xae, 0x8e, 0x15, 0x83, 0x58, 0xb2, 0x42, 0x00, 0xbe, 0x8f,
	0x76, 0xcd, 0x6c, 0x09, 0x85, 0x82, 0x2d, 0xec, 0xe5, 0x3a, 0x06, 0x7b, 0xaa, 0xa0, 0xe0, 0x47,
	0x07, 0x35, 0x26, 0x22, 0x7b, 0x51, 0x4a, 0x7c, 0x17, 0xdd, 0x62, 0x27, 0x05, 0xac, 0x0f, 0x6c,
	0x82, 0x4b, 0x3d, 0x76, 0x2e, 0xf5, 0xc0, 0x23, 0xd4, 0x34, 0x4a, 0x08, 0xcf, 0xd5, 0xeb, 0x6d,
	0x93, 0xe8, 0x48, 0x3f, 0x8d, 0x35, 0x1c, 0xaf, 0xeb, 0x82, 0xcf, 0x50, 0xd7, 0x4c, 0x51, 0xcd,
	0xae, 0xce, 0xb4, 0x60, 0x65, 0x21, 0x13, 0x0e, 0x29, 0xe4, 0x2b, 0xa0, 0x76, 0xae, 0xae, 0x81,
	0x63, 0x8b, 0x06, 0xbf, 0x3a, 0xa8, 0x39, 0x11, 0xd9, 0x31, 0x99, 0xc1, 0xcd, 0x57, 0x78, 0x1b,
	0x35, 0x4c, 0x5b, 0xeb, 0x55, 0x1b, 0xe1, 0x08, 0xdd, 0x31, 0xee, 0x5b, 0x40, 0x21, 0x93, 0x39,
	0x4b, 0x89, 0x36, 0x74, 0x5d, 0x93, 0xf0, 0xdf, 0xa9, 0xe7, 0x36, 0x83, 0x1f, 0xa0, 0xae, 0x41,
	0x13, 0x56, 0x24, 0x92, 0xcc, 0xd6, 0xb6, 0xdd, 0x35, 0xe8, 0xe7, 0x85, 0x9a, 0x33, 0x38, 0x46,
	0xfb, 0x76, 0xe4, 0x6a, 0xdf, 0x0d, 0x11, 0x9d, 0x1b, 0x8a, 0xf8, 0x93, 0x83, 0x0e, 0x26, 0x22,
	0xfb, 0x72, 0xa9, 0x8c, 0x67, 0x28, 0xcf, 0x00, 0x62, 0xf8, 0xbe, 0x04, 0x21, 0x95, 0x0a, 0x9c,
	0x31, 0x99, 0x10, 0x4a, 0x39, 0x08, 0xb1, 0x36, 0x83, 0xc2, 0x46, 0x06, 0xc2, 0x4f, 0x50, 0x8b,
	0x50, 0x9a, 0xbc, 0x04, 0x10, 0xde, 0xce, 0x35, 0x46, 0x8d, 0x9b, 0x84, 0xd2, 0x67, 0x00, 0x02,
	0xbf, 0x8b, 0xf6, 0x38, 0x2c, 0xd8, 0x0a, 0x8c, 0xbc, 0xc6, 0x04, 0x6d, 0xb5, 0xb1, 0x02, 0xb5,
	0xbe, 0x22, 0x78, 0x07, 0xf9, 0x57, 0x8d, 0x66, 0x96, 0x3f, 0x7c, 0xed, 0x22, 0x77, 0x22, 0x32,
	0xfc, 0x0d, 0x6a, 0xd8, 0xf7, 0xcd, 0x83, 0x2d, 0xdb, 0x57, 0x46, 0xf7, 0x1f, 0xfd, 0x17, 0x56,
	0x25, 0xf1, 0x17, 0xc8, 0x55, 0x3e, 0xbf, 0xbf, 0xbd, 0xe8, 0x45, 0x29, 0xfd, 0xf7, 0xaf, 0xa5,
	0x54, 0x4d, 0xbf, 0x42, 0x75, 0x6d, 0xbd, 0x60, 0x7b, 0x89, 0xe2, 0xf8, 0x1f, 0x5c, 0xcf, 0xa9,
	0xfa, 0xfe, 0x80, 0xf6, 0xff, 0xa1, 0x16, 0x7e, 0xb2, 0xbd, 0xfc, 0xea, 0xbb, 0xfb, 0x1f, 0xff,
	0xcf, 0x2a, 0xf3, 0xff, 0x47, 0xf1, 0x9b, 0xf3, 0x9e, 0x73, 0x76, 0xde, 0x73, 0xfe, 0x3c, 0xef,
	0x39, 0xaf, 0x2f, 0x7a, 0xb5, 0xb3, 0x8b, 0x5e, 0xed, 0xb7, 0x8b, 0x5e, 0xed, 0xeb, 0x4f, 0x37,
	0xde, 0x4c, 0xba, 0xf5, 0xe3, 0x02, 0xe4, 0x09, 0xe3, 0x33, 0x1b, 0xcd, 0x81, 0x66, 0xc0, 0xa3,
	0xd3, 0x4b, 0x5f, 0xa0, 0x69, 0x43, 0x7f, 0x59, 0x3e, 0xfa, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x29,
	0x36, 0x77, 0x09, 0xf7, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Create creates a bank denom which wraps credits.
	Create(ctx context.Context, in *MsgCreate, opts ...grpc.CallOption) (*MsgCreateResponse, error)
	// Put puts credits into a basket in return for basket tokens.
	Put(ctx context.Context, in *MsgPut, opts ...grpc.CallOption) (*MsgPutResponse, error)
	// Take takes credits from a basket starting from the oldest
	// credits first.
	Take(ctx context.Context, in *MsgTake, opts ...grpc.CallOption) (*MsgTakeResponse, error)
	// UpdateBasketFee updates the list of allowed denoms and their amounts to be used as basket creation fees - Governance only method
	UpdateBasketFee(ctx context.Context, in *MsgUpdateBasketFeeRequest, opts ...grpc.CallOption) (*MsgUpdateBasketFeeResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Create(ctx context.Context, in *MsgCreate, opts ...grpc.CallOption) (*MsgCreateResponse, error) {
	out := new(MsgCreateResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Put(ctx context.Context, in *MsgPut, opts ...grpc.CallOption) (*MsgPutResponse, error) {
	out := new(MsgPutResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Take(ctx context.Context, in *MsgTake, opts ...grpc.CallOption) (*MsgTakeResponse, error) {
	out := new(MsgTakeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/Take", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateBasketFee(ctx context.Context, in *MsgUpdateBasketFeeRequest, opts ...grpc.CallOption) (*MsgUpdateBasketFeeResponse, error) {
	out := new(MsgUpdateBasketFeeResponse)
	err := c.cc.Invoke(ctx, "/regen.ecocredit.basket.v1.Msg/UpdateBasketFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Create creates a bank denom which wraps credits.
	Create(context.Context, *MsgCreate) (*MsgCreateResponse, error)
	// Put puts credits into a basket in return for basket tokens.
	Put(context.Context, *MsgPut) (*MsgPutResponse, error)
	// Take takes credits from a basket starting from the oldest
	// credits first.
	Take(context.Context, *MsgTake) (*MsgTakeResponse, error)
	// UpdateBasketFee updates the list of allowed denoms and their amounts to be used as basket creation fees - Governance only method
	UpdateBasketFee(context.Context, *MsgUpdateBasketFeeRequest) (*MsgUpdateBasketFeeResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Create(ctx context.Context, req *MsgCreate) (*MsgCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedMsgServer) Put(ctx context.Context, req *MsgPut) (*MsgPutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (*UnimplementedMsgServer) Take(ctx context.Context, req *MsgTake) (*MsgTakeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Take not implemented")
}
func (*UnimplementedMsgServer) UpdateBasketFee(ctx context.Context, req *MsgUpdateBasketFeeRequest) (*MsgUpdateBasketFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBasketFee not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Create(ctx, req.(*MsgCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Put(ctx, req.(*MsgPut))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Take_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTake)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Take(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/Take",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Take(ctx, req.(*MsgTake))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateBasketFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateBasketFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateBasketFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/regen.ecocredit.basket.v1.Msg/UpdateBasketFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateBasketFee(ctx, req.(*MsgUpdateBasketFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "regen.ecocredit.basket.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Msg_Create_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _Msg_Put_Handler,
		},
		{
			MethodName: "Take",
			Handler:    _Msg_Take_Handler,
		},
		{
			MethodName: "UpdateBasketFee",
			Handler:    _Msg_UpdateBasketFee_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "regen/ecocredit/basket/v1/tx.proto",
}

func (m *MsgCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.DateCriteria != nil {
		{
			size, err := m.DateCriteria.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.AllowedClasses) > 0 {
		for iNdEx := len(m.AllowedClasses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedClasses[iNdEx])
			copy(dAtA[i:], m.AllowedClasses[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AllowedClasses[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CreditTypeAbbrev) > 0 {
		i -= len(m.CreditTypeAbbrev)
		copy(dAtA[i:], m.CreditTypeAbbrev)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CreditTypeAbbrev)))
		i--
		dAtA[i] = 0x32
	}
	if m.DisableAutoRetire {
		i--
		if m.DisableAutoRetire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Exponent != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Curator) > 0 {
		i -= len(m.Curator)
		copy(dAtA[i:], m.Curator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Curator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmountReceived) > 0 {
		i -= len(m.AmountReceived)
		copy(dAtA[i:], m.AmountReceived)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AmountReceived)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RetireOnTake {
		i--
		if m.RetireOnTake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.RetirementLocation) > 0 {
		i -= len(m.RetirementLocation)
		copy(dAtA[i:], m.RetirementLocation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RetirementLocation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTakeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTakeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTakeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBasketFeeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBasketFeeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBasketFeeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoveDenoms) > 0 {
		for iNdEx := len(m.RemoveDenoms) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RemoveDenoms[iNdEx])
			copy(dAtA[i:], m.RemoveDenoms[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.RemoveDenoms[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AddFees) > 0 {
		for iNdEx := len(m.AddFees) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddFees[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RootAddress) > 0 {
		i -= len(m.RootAddress)
		copy(dAtA[i:], m.RootAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RootAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateBasketFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateBasketFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateBasketFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Curator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovTx(uint64(m.Exponent))
	}
	if m.DisableAutoRetire {
		n += 2
	}
	l = len(m.CreditTypeAbbrev)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AllowedClasses) > 0 {
		for _, s := range m.AllowedClasses {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.DateCriteria != nil {
		l = m.DateCriteria.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AmountReceived)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RetirementLocation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RetireOnTake {
		n += 2
	}
	return n
}

func (m *MsgTakeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateBasketFeeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RootAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AddFees) > 0 {
		for _, e := range m.AddFees {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.RemoveDenoms) > 0 {
		for _, s := range m.RemoveDenoms {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateBasketFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Curator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoRetire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoRetire = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeAbbrev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeAbbrev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedClasses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedClasses = append(m.AllowedClasses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateCriteria == nil {
				m.DateCriteria = &DateCriteria{}
			}
			if err := m.DateCriteria.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountReceived = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetirementLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetirementLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetireOnTake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetireOnTake = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTakeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTakeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTakeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBasketFeeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBasketFeeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBasketFeeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddFees = append(m.AddFees, &types.Coin{})
			if err := m.AddFees[len(m.AddFees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveDenoms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoveDenoms = append(m.RemoveDenoms, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateBasketFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateBasketFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateBasketFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
